## MIPS Implementation of a subset of routines defined by string.h 

## Testing:
##   * test code is located at the end of the file.
##   * uncomment the following line
.globl main


	.text
.globl memcpy
# byte * memcpy(byte *dst, byte *src, int length);

.globl memccpy
# byte * memccpy(byte *dst, byte *src, int last_char, int max_length);

.globl memmove
# byte * memmove(void *dst, byte*src, int len);
   # memmove calls memcpy and it presumes that the $a registers are unaltered
   # This diverages from the MIPS subroutine calling convention


.globl memchr
# byte * memchr(byte *src, byte c, int max_length);
// memchr -- set a byte in memory

.globl memchr
# byte *memset(byte *dst, byte c, int length);
// memset - locate a byte in memory

.globl memchr
# int   memcmp(byte * s1, byte * s2, int length);
// memcmp -- compare bytes in memory




#####################################
.ent memcpy
memcpy:	nop   		# void * memcpy(&dst, &src, length)
			# note: NO check is made if the strings overlap
            # v0: dst (the original)
            # v1: <unaltered>
	# a0: dst
	# a1: src
	# a2: length
	# a3: <unaltered>

	# t0: c
	# t1: temp

	move $v0, $a0
 	li $t0, 0             
t_memcpy:
 	bge $t0, $a2, d_memcpy    # for (c=0; c < length, c++) {
 	lb $t1, 0($a1)            #   temp    = (* src);
 	sb $t1, 0($a0) 	  #   (* dst) = temp;
 	addi $a0, $a0, 1  	  #   dst ++;
 	addi $a1, $a1, 1          #   src ++;
	addi $t0, $t0, 1          #   c++;
 	b t_memcpy
                           
d_memcpy: 	nop	              # }
	jr $ra                    # return;
.end memcpy



#####################################
.ent memccpy
memccpy:	nop			# void * memccpy(&dst, &src, char_last, max_length)
				# note:  NO check is made if the strings overlap

            # v0: ret_val 
            # v1: <unaltered>		
	# a0: &dst
	# a1: &src
	# a2: char_stop
	# a3: max_length
	# t0: c

 	li $v0, 0                  	# retval = NULL;   
 	li $t0, 0 		   	# c=0;
t_memccpy:	
 	bge $t0, $a3, d_memccpy    	# for (c=0; c < length, c++) {
 	lb $t1, 0($a1)             	#   temp = (* src);
 	sb $t1, 0($a0) 	   	#   (* dst) = temp;
	
 	bne $t1, $a2, c_memccpy    	#   if (temp == char_last) {
	addi $v0, $a0, 1	   	#      ret_val = dst + 1
 	jr $ra	               	#      return; 			   
 		               	#   }
 c_memccpy:	addi $a0, $a0, 1  	   	#   dst ++;
 	addi $a1, $a1, 1           	#   src ++;
	addi $t0, $t0, 1           	#   c++;
 	b t_memccpy	
                           	
d_memccpy: 	nop	               	# }
	jr $ra                     	# return ret_val;
.end memccpy



///  bug: need to save the value of the $ra register on my call to memcpy...


#####################################
.ent memmove
memmove:	nop			# void * memmove(&dst, &src, length)
				# Note: Address overlapping string
            # v0: ret_val (dst)
            # v1: <unaltered>
	# a0: dst
	# a1: src
	# a2: length
	# t0: overlap
	
	# Non-leaf node (i.e., it makes subroutine calls)
	# Only $a0 is overwritten
	# Hence save: ra, sp, a0, $t0

  	# Steps:
  	#   1. Determine if the strings overlap.
  	#   2. If overlap
  	#      * allocate stack space
  	#      * memcpy "src" onto the stack
  	#      * reset the value of "src"
  	#   3. memcpy "src" into "dst"
  	#   4. If overlap
  	#      * deallocate stack space


            ##########################################################
  	#   1. Determine if the strings overlap.
           	#      t1: first, end
	#      t2: second
	li $t0, 0	  		# overlap = FALSE
 	bgt $a0, $a1, reorder   	# first, second = order(dst, src);   
 	  move $t1, $a0
 	  move $t2, $a1
 	b next
reorder:	  move $t1, $a1
 	  move $t2, $a0
 	# b next

next: 	add $t1, $t1, $a3       	# end = first + length;
	sge $t0, $t1, $a2       	# overlap = (end >= length);
            ##########################################################

            ##########################################################
	#   2. If overlap
  	#      t3: temp
            bne $t0, $zero, separate  	# if ( overlap ) {
              addi $t3, $sp, -1       	#   temp = alloca(length);
              subu $sp, $sp, $a3

	  nop   			#   src  = memcpy(temp, src, length);
	  push $ra 			#        // save registers
	  push $sp 			#
	  push $a0	
	  push $t0	
              move $a0, $t3         	#       // marshall inputs
              jal memcpy 		#       // update the PC and $ra
              pop $t0 			#       // restore registers
              pop $a0	
              pop $sp 			#          
              pop $ra 			#  
              move $a1, $v0		#       // demarshall outputs
            nop                     	# }

separate:   nop	            	# dst = memcpy(dst, src, length);
	pop $sp 			#     // save registers
	pop $ra			#     
	# move $a0, $a0, etc.   	#     // marshall inputs
            jal memcpy     		#     // update the PC and $ra
            pop $ra 			#     // restore registers         
            # move $v0, $v0      		#     // demarshall outputs
	
            bne $t0, $zero, done 		# if ( overlap ) {		
            addu $sp, $sp, $a3      	#    ;  // deallocate stack space
                                    	# }
done:	jr $ra                  	# return dst;
                                    	# }
.end memmove


####################################
### TEST CODE


	.data
	.align 3
s_string:	.ascii  "This is that start!"
o_string:   .asciiz " Overlapping"
	.space  10
	.align 3
d_string:	.space  50
	.align 3
t_string:	.space  50

	.text
main:   nop   # testing code
	la $a0, d_string
	la $a1, s_string
	li $a2, 28
	jal memcpy
	# d_string: This is that start! Overlapp


	la $a0, t_string
	la $a1, s_string
	li $a2, '!'
	li $a3, 28
	jal memccpy 
	# t_string: This is that start!
	# v0 = overlap

	la $a0, o_string
	la $a1, s_string
	li $a2, 25
	jal memmove
	# o_string: This is that start! Overl

